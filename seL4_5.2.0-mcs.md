# seL4 MCS pre-release (5.2.0-mcs)


This is a pre-release of the seL4 mixed-criticality systems (RT)
extensions. This branch is not verified and is under active
verification. This is a subset of the previously released RT extensions,
which still exist and can be provided on request.

## Highlights


The goals of the MCS kernel is to provide strong temporal isolation and
a basis for reasoning about time.

### IPC & Signal ordering


Signal and IPC delivery is now priority ordered and FIFO within a
priority, rather than plain FIFO

### Scheduling contexts


This branch adds scheduling contexts to seL4, which represent CPU time
(as budget/period). Scheduling contexts are separate from threads
(although threads require one to run) and can be passed around over IPC,
if the target of an IPC does not have its own scheduling context.

Scheduling contexts allow developers to create periodic threads,
temporally isolate threads and have variable timeslices for round robin
threads. If budget == period, the scheduling context acts as timeslice
and the thread it is bound to is treated as round-robin.

### Periodic scheduling


Periodic threads can be created by binding them to scheduling contexts
with a budget &lt; period. seL4\_Yield for these threads will sacrifice
the remaining budget until the next period.

### Isolation through sporadic servers


Temporal isolation is provided with scheduling context by an
implementation of
\[\[<https://www.cs.fsu.edu/~awang/papers/rtas2010.pdf%7Csporadic>
servers\]\]. Please see the \[\[manual\]\] or tutorial for further
explanation.

However, in seL4, threads without budget left in their sporadic server
are not runnable at all - this is used to provide an absolute cap on CPU
time executed by a scheduling context. More complex scheduling
algorithms can be implemented at user-level.

Scheduling contexts are of a variable size, allowing for a variable
maximum number of sporadic replenishment (termed refills in the API for
brevity) pre scheduling context object.

### Passive Servers


Passive servers run on their clients scheduling context, as the do not
have one of their own. This allows for basic temporal isolation of
shared resources, however clients must provide enough budget for the
server to finish the request. Futher extensions in future add timeout
exceptions, which allows a passive server to detect and recover from an
overrun, however they are not included in this release.

Threads can be converted to passive by removing their scheduling context
while they are waiting on an endpoint. Then, any calling threads will
automatically donate their scheduling context to this thread when they
send it an IPC.

### Reply objects


Reply objects are a new object in the API which serve two purposes:

> -   They provide a container for the once-off reply capability
>     generated by a seL4\_Call to be stored. This means that the reply
>     cap is always saved and cannot be overriden as it is no longer
>     stored in the internal CNode of a TCB, and seL4\_CNode\_SaveCaller
>     no longer needs to be used.
> -   They track scheduling context donation over IPC to
>     passive servers.

## MCS ABI and libsel4


This section documents kernel ABI and libsel4 changes as compared with
seL4 5.2.0.

### Changes


> -   seL4\_TCB\_Configure arguments changed (scheduling context
>     cap added).
> -   seL4\_Recv, seL4\_ReplyRecv, seL4\_NBRecv now take a reply object
>     such that the caller can receive a call. The reply capability is
>     generated in the reply object, rather than being saved into the
>     TCB CNode internally. seL4\_Call must be paired with seL4\_Recv -
>     and seL4\_CNode\_SaveCaller is no longer required.
> -   seL4\_Wait, seL4\_NBWait and variants do not require a reply
>     object and can be paired with seL4\_Send on endpoints
>     and notifications. Instead of being an API wrapper, this is now a
>     real system call.
> -   the x86 kernel ABI now only has 1 message register, due to the
>     need to store the reply object.
> -   seL4\_MsgLengthBits increased - this increases amount of caps can
>     be sent per message.
> -   seL4\_MsgMaxLength is now 115, as a result.
> -   seL4\_NotificationBits - increased.

### API Additions


#### Constants


> -   seL4\_SchedContextObject - new object for that allows threads
>     access to CPU time
> -   seL4\_MinSchedContextBits - minimum size n (2\^n) of a scheduling
>     context object
> -   seL4\_CoreSchedContextBytes - the amount of bytes required for the
>     fields in a scheduling context that are not sporadic refills.
> -   seL4\_RefillSizeBytes - the size of a single refill. Together with
>     the above, these can be used to determine the number of refills
>     that will fit in a scheduling context object of a certain size.
> -   seL4\_ReplyObject - new object to track scheduling context
>     donation over IPC and store reply capabilities.
> -   seL4\_ReplyObjectBits - size of a reply object (2\^n).
> -   seL4\_CapInitThreadSC - capability to the initial threads
>     scheduling context

#### System calls


> -   seL4\_NBSendRecv - new system call which allows a single kernel
>     invocation to perform a non-blocking send on one capability, and
>     recieve on another.
> -   seL4\_NBSendRecvWithMRs - uses above new system call without
>     touching the IPC buffer, passing only data in registers
> -   seL4\_NBSendWait - new system call which allows a single kernel
>     invocation to perform a non-blocking send on one capability, and
>     wait on another (no reply object).
> -   seL4\_NBSendWaitWithMRs - uses above new system call without
>     touching the IPC buffer, passing only data in registers
> -   seL4\_SchedControl\_Configure - invokes the scheduling control cap
>     to populate a scheduling context with parameters
> -   seL4\_SchedContext\_Bind - bind a TCB to a scheduling context, if
>     the TCB is runnable and scheduling context has budget, this will
>     start the TCB running
> -   seL4\_SchedContext\_Unbind - remove binding of a scheduling
>     context from a TCB, TCB will no longer run but state will be
>     preserved
> -   seL4\_SchedContext\_Unbind Object - remove binding of a scheduling
>     context from a TCB, TCB will no longer run but state will be
>     preserved
> -   seL4\_Wait - block on an endpoint or notification without
>     providing a reply object. Can be paired with seL4\_Send but
>     not seL4\_Call.
> -   seL4\_NBWait - a non-blocking variant of the above.
> -   seL4\_WaitWithMRs - a variant of seL4\_Wait that does not touch
>     the IPC buffer.

#### libsel4


> -   seL4\_SetReserved, \`seL4\_GetReserved\`: set a reserved word in
>     the IPC buffer that may be used by the kernel ABI for arguments
>     that do not fit into registers.
> -   seL4\_MaxExtraRefills is provided to allow users to calculate the
>     maximum number of extra refills for a specific scheduling
>     context size.
> -   \`seL4\_Time\`: type for specifying time arguments.

#### Structures


> -   A sched control capability is provided to the root task per node
>     via the seL4\_BootInfo structure.

### Deletions


> -   seL4\_CNode\_SaveCaller (deprecated by reply objects)
> -   seL4\_Reply (replaced by invoking a reply object)
> -   seL4\_ReplyWithMRs(as above)

## Library & test compatability


> -   CAmkES and CapDL both support seL4 5.2.0-mcs on their
>     master branches.
> -   seL4\_libs and sel4test both have 5.2.0-mcs-compatible branches
>     that work with the forked API
> -   You can obtain and run sel4test for seL4 5.2.0-mcs by doing the
>     following:

{{{ \$ mkdir sel4test-mcs \$ cd sel4test-mcs \$ repo init -u
<https://github.com/seL4/sel4test-manifest.git> -m 5.2.x-mcs.xml \$ repo
sync }}}

> -   A \[\[<https://wiki.sel4.systems/seL4%20RT%20tutorial%7Cnew>
>     tutorial\]\] covers the difference in the APIs

## Hardware support


The RT kernel currently supports:

> -   \[\[Hardware/BeagleBoard|BeagleBoard\]\]
> -   \[\[Hardware/sabreLite|SabreLite\]\]
> -   \[\[<https://wiki.sel4.systems/Hardware/IA32%7Cx86> (ia32, x64),
>     multicore\]\]
> -   \[\[Hardware/jetsontk1|Tegra TK1\]\]

Other hardware platforms will be added as required (the ports require
updated kernel and user-level timer drivers)

## More details


See the 5.2.0-mcs manual included in the release.

We have developed a branch of the seL4 and CAmkES tutorials for the MCS
kernel.

> -   \[\[seL4 RT tutorial\]\] a new tutorial which covers all of the
>     API changes and features is available here.
> -   \[\[Tutorials\]\] Otherwise it's worth going through all of the
>     tutorials, as all have been ported to the MCS kernel on the
>     'mcs' branch.

