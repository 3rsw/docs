##master-page:HelpTemplate
##master-date:Unknown-Date
#format wiki
#language en

= Content =
<<TableOfContents(3)>>

= CAmkES Tutorial =
This tutorial will help you walk-through building application with procedure, event and dataport connectors.

== RPC Application ==
Let's create some simple hello world applications using the different interface types available in CAmkES. Create a new application directory with two component types:

=== Setup Directories ===
{{{
mkdir -p apps/helloworld/components/Hello
mkdir -p apps/helloworld/components/Client
}}}

=== Setup Interface ===
Functional interfaces, referred to as procedures, are made up of a set of methods. Define an interface that the components will communicate over and save this under apps/helloworld/interfaces/MyInterface.idl4:
{{{
/* apps/helloworld/interfaces/MyInterface.idl4 */

procedure MyInterface {
  void print(in string message);
};
}}}
This interface consists of a single method, print that takes an input parameter of type string. Note that, although we are planning to implement this component in C, interfaces are defined with abstract types that have equivalents in all target languages. In the case of C, string maps to char*. Each component needs a description of the interfaces it exposes or needs in so-called Architecture Description Language. Create these in apps/helloworld/components/Hello/Hello.camkes and apps/helloworld/components/Client/Client.camkes.

=== Setup Components' CAmkES Files ===
{{{
/* apps/helloworld/components/Hello/Hello.camkes */

import "../../interfaces/MyInterface.idl4";

component Hello {
  provides MyInterface inf;
}

/* apps/helloworld/components/Client/Client.camkes */

import "../../interfaces/MyInterface.idl4";

component Client {
  control;
  uses MyInterface iface;
}
}}}
Note that each component description needs to import the interface file we created above from apps/helloworld/interfaces. Import statements function similar to C's #include, in that they can be enclosed in double quotes and are relative to the source file, or enclosed in angle brackets and refer to a built-in file. The Hello component is to contain an implementation of MyInterface and the Client component will expect to be provided with an implementation of MyInterface. The control keyword indicates that Client is what is called an active component. This means it will contain a main function (prototyped as run) and have an active thread of control.

=== Setup Composition CAmkES File ===
Create a file to describe the instantiation and structure of the system at apps/helloworld/helloworld.camkes.
{{{
/* apps/helloworld/helloworld.camkes */

import <std_connector.camkes>;
import "components/Hello/Hello.camkes";
import "components/Client/Client.camkes";

assembly {
  composition {
    component Hello h;
    component Client c;
    connection seL4RPC conn(from c.iface, to h.inf);
  }
}
}}}
This file begins with several import statements that reference other files. Hello.camkes and Client.camkes are the files we created above, while std_connector.camkes is a built-in file that defines the standard CAmkES connector types. The body of the system description instantiates each component once, h of type Hello and c of type Client. The components' interfaces are connected via a connection, conn, of type seL4RPC.

=== Implement Components ===
Now for the implementation of the components. Create a single source file for Hello as apps/helloworld/components/Hello/src/hello.c:
{{{#!highlight c
/* apps/helloworld/components/Hello/src/hello.c */

#include <camkes.h>
#include <stdio.h>

void inf__init(void) {
}

void inf_print(const char *message) {
  printf("Client says: %s\n", message);
}
}}}
The header camkes.h is generated by the CAmkES build system and contains prototypes for functions related to MyInterface that this component needs to implement. Note that the actual implementations of interface functions are prefixed with the component-local name of the interface (inf from Hello.camkes above) and an underscore. The function {{{inf__init}}} is for this component to do any required initialisation. In the case of this example we have no initialisation to perform.

Create a source file for Client as apps/helloworld/components/Client/src/client.c that calls these functions as if they are directly available to it:
{{{#!highlight c
/* apps/helloworld/components/Client/src/client.c */

#include <camkes.h>

int run(void) {
  const char *s = "hello world";
  iface_print(s);
  return 0;
}
}}}
The entry point of a CAmkES component is run.

=== Merge your application to build system ===
The final thing is to add some build system boiler plate to be able to build the system. Create apps/helloworld/Kconfig for the build system menu:
{{{#!highlight makefile
# apps/helloworld/Kconfig

config APP_HELLOWORLD
bool "Hello world CAmkES application"
default n
    help
        Hello world tutorial exercise.
}}}

Create a dependency entry in apps/helloworld/Kbuild for your application:
{{{#!highlight makefile
# apps/helloworld/Kbuild

apps-$(CONFIG_APP_HELLOWORLD) += helloworld
helloworld: libsel4 libmuslc libsel4platsupport \
  libsel4muslccamkes libsel4sync libsel4debug libsel4bench
}}}

Copy one of the Makefiles from another application or create apps/helloworld/Makefile from scratch:
{{{#!highlight makefile
# apps/helloworld/Makefile

TARGETS := helloworld.cdl
ADL := helloworld.camkes

Client_CFILES = components/Client/src/client.c
Hello_CFILES = components/Hello/src/hello.c

include ${SOURCE_DIR}/../../tools/camkes/camkes.mk
}}}

Add a source line to the top-level Kconfig under the applications menu that references this file:
{{{
source "apps/helloworld/Kconfig"
}}}

You can now run {{{make menuconfig}}} from the top-level directory and select your application from the Applications menu. Make sure you deselect the simple application while you're here.

=== Build and Run ===
You're now ready to compile and run this application:
{{{
make clean
make
qemu-system-arm -M kzm -nographic -kernel \
  images/capdl-loader-experimental-image-arm-imx31
}}}

If all goes well you should see:
{{{
Client says: hello world
}}}

Congratulations, you've just made your first CAmkES application.

=== Under the Hood ===
We basically just wrote a verbose and roundabout Hello World example, so what benefit is CAmkES providing here? Note how the function call between the two components looks just like a normal function invocation in C, even though the two components are actually in different address spaces. During compilation so-called glue code is generated to connect the two components via a seL4 endpoint and transparently pass the function invocation and return over this channel. The communication itself is abstracted in the ADL description in apps/helloworld/helloworld.camkes. The connection type we used was seL4RPC, but it is possible to use another connection type here without modifying the code of the components themselves.
