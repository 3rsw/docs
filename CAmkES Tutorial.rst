##master-page:HelpTemplate
##master-date:Unknown-Date
#format wiki
#language en

<<TableOfContents(3)>>

= CAmkES Tutorial =
This tutorial will help you walk-through building application with procedure, event and dataport connectors.

== Procedure Application ==
Let's create some simple hello world applications using the different interface types available in CAmkES. Create a new application directory with two component types:

=== Setup Directory ===
{{{
mkdir -p apps/helloworld/components/Hello
mkdir -p apps/helloworld/components/Client
}}}

=== Setup Interface ===
Functional interfaces, referred to as procedures, are made up of a set of methods. Define an interface that the components will communicate over and save this under apps/helloworld/interfaces/MyInterface.idl4:
{{{
/* apps/helloworld/interfaces/MyInterface.idl4 */

procedure MyInterface {
  void print(in string message);
};
}}}
This interface consists of a single method, print that takes an input parameter of type string. Note that, although we are planning to implement this component in C, interfaces are defined with abstract types that have equivalents in all target languages. In the case of C, string maps to char*. Each component needs a description of the interfaces it exposes or needs in so-called Architecture Description Language. Create these in apps/helloworld/components/Hello/Hello.camkes and apps/helloworld/components/Client/Client.camkes.

=== Setup Components' CAmkES Files ===
{{{
/* apps/helloworld/components/Hello/Hello.camkes */

import "../../interfaces/MyInterface.idl4";

component Hello {
  provides MyInterface inf;
}
}}}
{{{
/* apps/helloworld/components/Client/Client.camkes */

import "../../interfaces/MyInterface.idl4";

component Client {
  control;
  uses MyInterface iface;
}
}}}
Note that each component description needs to import the interface file we created above from apps/helloworld/interfaces. Import statements function similar to C's #include, in that they can be enclosed in double quotes and are relative to the source file, or enclosed in angle brackets and refer to a built-in file. The Hello component is to contain an implementation of MyInterface and the Client component will expect to be provided with an implementation of MyInterface. The control keyword indicates that Client is what is called an active component. This means it will contain a main function (prototyped as run) and have an active thread of control.

=== Setup Composition CAmkES File ===
Create a file to describe the instantiation and structure of the system at apps/helloworld/helloworld.camkes.
{{{
/* apps/helloworld/helloworld.camkes */

import <std_connector.camkes>;
import "components/Hello/Hello.camkes";
import "components/Client/Client.camkes";

assembly {
  composition {
    component Hello h;
    component Client c;
    connection seL4RPC conn(from c.iface, to h.inf);
  }
}
}}}
This file begins with several import statements that reference other files. Hello.camkes and Client.camkes are the files we created above, while std_connector.camkes is a built-in file that defines the standard CAmkES connector types. The body of the system description instantiates each component once, h of type Hello and c of type Client. The components' interfaces are connected via a connection, conn, of type seL4RPC.

=== Implement Components ===
Now for the implementation of the components. Create a single source file for Hello as apps/helloworld/components/Hello/src/hello.c:
{{{#!highlight c
/* apps/helloworld/components/Hello/src/hello.c */

#include <camkes.h>
#include <stdio.h>

void inf__init(void) {
}

void inf_print(const char *message) {
  printf("Client says: %s\n", message);
}
}}}
The header camkes.h is generated by the CAmkES build system and contains prototypes for functions related to MyInterface that this component needs to implement. Note that the actual implementations of interface functions are prefixed with the component-local name of the interface (inf from Hello.camkes above) and an underscore. The function {{{inf__init}}} is for this component to do any required initialisation. In the case of this example we have no initialisation to perform.

Create a source file for Client as apps/helloworld/components/Client/src/client.c that calls these functions as if they are directly available to it:
{{{#!highlight c
/* apps/helloworld/components/Client/src/client.c */

#include <camkes.h>

int run(void) {
  const char *s = "hello world";
  iface_print(s);
  return 0;
}
}}}
The entry point of a CAmkES component is run.

=== Merge Application to Build System ===
The final thing is to add some build system boiler plate to be able to build the system. Create apps/helloworld/Kconfig for the build system menu:
{{{#!highlight makefile
# apps/helloworld/Kconfig

config APP_HELLOWORLD
bool "Hello world CAmkES application"
default n
    help
        Hello world tutorial exercise.
}}}

Create a dependency entry in apps/helloworld/Kbuild for your application:
{{{#!highlight makefile
# apps/helloworld/Kbuild

apps-$(CONFIG_APP_HELLOWORLD) += helloworld
helloworld: libsel4 libmuslc libsel4platsupport \
  libsel4muslccamkes libsel4sync libsel4debug libsel4bench
}}}

Copy one of the Makefiles from another application or create apps/helloworld/Makefile from scratch:
{{{#!highlight makefile
# apps/helloworld/Makefile

TARGETS := helloworld.cdl
ADL := helloworld.camkes

Client_CFILES = components/Client/src/client.c
Hello_CFILES = components/Hello/src/hello.c

include ${SOURCE_DIR}/../../tools/camkes/camkes.mk
}}}

Add a source line to the top-level Kconfig under the applications menu that references this file:
{{{
source "apps/helloworld/Kconfig"
}}}

You can now run '''make menuconfig''' from the top-level directory and select your application from the Applications menu. Make sure you '''deselect the simple application''' while you're here.

=== Build and Run ===
You're now ready to compile and run this application:
{{{
make clean
make
qemu-system-arm -M kzm -nographic -kernel \
  images/capdl-loader-experimental-image-arm-imx31
}}}

If all goes well you should see:
{{{
Client says: hello world
}}}

Congratulations, you've just made your first CAmkES application.

=== Under the Hood ===
We basically just wrote a verbose and roundabout Hello World example, so what benefit is CAmkES providing here? Note how the function call between the two components looks just like a normal function invocation in C, even though the two components are actually in different address spaces. During compilation so-called glue code is generated to connect the two components via a seL4 endpoint and transparently pass the function invocation and return over this channel. The communication itself is abstracted in the ADL description in apps/helloworld/helloworld.camkes. The connection type we used was seL4RPC, but it is possible to use another connection type here without modifying the code of the components themselves.

== Event Application ==
Events are the CAmkES interface type for modelling asynchronous communication between components. Like procedures, events connect a single component to another single component, but the receiver of an event (called consumer in CAmkES parlance) has several ways of receiving the event. The following walks through an example demonstrating these.

=== Setup Directory ===
Create a new application directory with two components:
{{{
mkdir -p apps/helloevent/components/Emitter
mkdir -p apps/helloevent/components/Consumer
}}}

=== Setup Components' CAmkES Files ===
Events, unlike procedures, do not need to be defined in a separate IDL file. You can simply refer to the event type in your component ADL files and CAmkES will infer an event type. Create the following description for Emitter:
{{{
/* apps/helloevent/components/Emitter/Emitter.camkes */

component Emitter {
  control;
  emits MyEvent e;
}
}}}
This description says Emitter is an active component (the control keyword) and it emits a single event called e of type MyEvent. Create some basic source code for the component that does nothing except emit the event itself.

Now let's create a description of the Consumer that will handle this event:
{{{
/* apps/helloevent/components/Consumer/Consumer.camkes */

component Consumer {
  control;
  consumes MyEvent s;
}
}}}

=== Setup Composition CAmkES File ===
Note that this component consumes (handles) an event of the same type. Let's instantiate and connect these components together using another ADL file:
{{{
/* apps/helloevent/helloevent.camkes */

import <std_connector.camkes>;
import "components/Emitter/Emitter.camkes";
import "components/Consumer/Consumer.camkes";

assembly {
  composition {
    component Emitter source;
    component Consumer sink;
    connection seL4Notification channel(from source.e, to sink.s);
  }
}
}}}
In this file, seL4Notification is a seL4 specific connector for transmitting asynchronous signals. The two instantiated components, source and sink are connected over the connection channel.

=== Implement Components ===
{{{#!highlight c
/* apps/helloevent/components/Emitter/src/main.c */

#include <camkes.h>

int run(void) {
  while (1) {
    e_emit();
  }
  return 0;
}
}}}
CAmkES provides an emit function to send the event.

As mentioned above, there are several ways for a component to receive an event. The consumer can register a callback function to be invoked when the event is received, they can call a blocking function that will return when the event is received or they can call a polling function that returns whether an event has arrived or not. Let's add some source code that uses all three:
{{{#!highlight c
/* apps/helloevent/components/Consumer/src/main.c */

#include <camkes.h>
#include <stdio.h>

static void handler(void) {
  static int fired = 0;
  printf("Callback fired!\n");
  if (!fired) {
    fired = 1;
    s_reg_callback(&handler);
  }
}

int run(void) {
  printf("Registering callback...\n");
  s_reg_callback(&handler);

  printf("Polling...\n");
  if (s_poll()) {
    printf("We found an event!\n");
  } else {
    printf("We didn't find an event\n");
  }

  printf("Waiting...\n");
  s_wait();
  printf("Unblocked by an event!\n");

  return 0;
}
}}}
Note that we re-register the callback during the first execution of the handler. Callbacks are deregistered when invoked, so if you want the callback to fire again when another event arrives you need to explicitly re-register it.

=== Merge Application to Build System ===
We now have everything we need to run this system. Add the appropriate information to Kconfig, apps/helloevent/Kbuild, apps/helloevent/Kconfig and apps/helloevent/Makefile as for the previous example. Create apps/helloevent/Kconfig for the build system menu:
{{{#!highlight makefile
# apps/helloevent/Kconfig

config APP_HELLOEVENT
bool "Example event CAmkES application"
default n
    help
        Hello event tutorial exercise.
}}}

Create a dependency entry in apps/helloevent/Kbuild for your application:
{{{#!highlight makefile
# apps/helloevent/Kbuild

apps-$(CONFIG_APP_HELLOEVENT) += helloevent
helloevent: libsel4 libmuslc libsel4platsupport \
  libsel4muslccamkes libsel4sync libsel4debug libsel4bench
}}}

Copy one of the Makefiles from another application or create apps/helloevent/Makefile from scratch:
{{{#!highlight makefile
# apps/helloevent/Makefile

TARGETS := helloevent.cdl
ADL := helloevent.camkes

Consumer_CFILES = components/Consumer/src/main.c
Emitter_CFILES = components/Emitter/src/main.c

include ${SOURCE_DIR}/../../tools/camkes/camkes.mk
}}}

Add a source line to the top-level Kconfig under the applications menu that references this file:
{{{
source "apps/helloevent/Kconfig"
}}}

You can now run '''make menuconfig''' from the top-level directory and select your application from the Applications menu. Make sure you '''deselect the helloworld application''' while you're here.

=== Build and Run ===
Compile the system and run it with similar qemu commands to the previous example:
{{{
make clean
make
qemu-system-arm -M kzm -nographic -kernel \
  images/capdl-loader-experimental-image-arm-imx31
}}}

If all goes well you should see something like the following
{{{
Registering callback...
Callback fired!
Polling...
We didn't find an event
Waiting...
Unblocked by an event!
Callback fired!
}}}

=== Under the Hood ===
Whether you find an event during polling will be a matter of the schedule that seL4 uses to run the components. This covers all the functionality available when using events. One final point that may not be obvious from the example is that callbacks will always be fired in preference to polling/waiting. That is, if a component registers a callback and then waits on an event to arrive, the callback will be fired when the first instance of the event arrives and the wait will return when/if the second instance of the event arrives.
