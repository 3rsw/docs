\#\#master-page:HelpTemplate \#\#master-date:Unknown-Date \#format wiki
\#language en

&lt;&lt;TableOfContents(3)&gt;&gt;

= CAmkES Tutorial = This tutorial will help you walk-through building
application with remote procedure, event and dataport connectors.

== Remote Procedure Application == {{<attachment:echo.png>}}

Let's create some simple hello world applications using the different
interface types available in CAmkES. Create a new application directory
with two component types:

=== Setup Directory === {{{ mkdir -p apps/helloworld/components/Hello
mkdir -p apps/helloworld/components/Client }}}

=== Setup Interface === Functional interfaces, referred to as
procedures, are made up of a set of methods. Define an interface that
the components will communicate over and save this under
apps/helloworld/interfaces/MyInterface.idl4: {{{ /\*
apps/helloworld/interfaces/MyInterface.idl4 \*/

procedure MyInterface {

:   void print(in string message);

};
==

This interface consists of a single method, print that takes an input
parameter of type string. Note that, although we are planning to
implement this component in C, interfaces are defined with abstract
types that have equivalents in all target languages. In the case of C,
string maps to char\*. Each component needs a description of the
interfaces it exposes or needs in so-called Architecture Description
Language. Create these in apps/helloworld/components/Hello/Hello.camkes
and apps/helloworld/components/Client/Client.camkes.

=== Setup Components' CAmkES Files === {{{ /\*
apps/helloworld/components/Hello/Hello.camkes \*/

import "../../interfaces/MyInterface.idl4";

component Hello {

:   provides MyInterface inf;

}
=

{{{ /\* apps/helloworld/components/Client/Client.camkes \*/

import "../../interfaces/MyInterface.idl4";

component Client {

:   control; uses MyInterface iface;

}
=

Note that each component description needs to import the interface file
we created above from apps/helloworld/interfaces. Import statements
function similar to C's \#include, in that they can be enclosed in
double quotes and are relative to the source file, or enclosed in angle
brackets and refer to a built-in file. The Hello component is to contain
an implementation of MyInterface and the Client component will expect to
be provided with an implementation of MyInterface. The control keyword
indicates that Client is what is called an active component. This means
it will contain a main function (prototyped as run) and have an active
thread of control.

=== Setup Composition CAmkES File === Create a file to describe the
instantiation and structure of the system at
apps/helloworld/helloworld.camkes. {{{ /\*
apps/helloworld/helloworld.camkes \*/

import &lt;std\_connector.camkes&gt;; import
"components/Hello/Hello.camkes"; import
"components/Client/Client.camkes";

assembly {

:   

    composition {

    :   component Hello h; component Client c; connection seL4RPC
        conn(from c.iface, to h.inf);

    }

}
=

This file begins with several import statements that reference other
files. Hello.camkes and Client.camkes are the files we created above,
while std\_connector.camkes is a built-in file that defines the standard
CAmkES connector types. The body of the system description instantiates
each component once, h of type Hello and c of type Client. The
components' interfaces are connected via a connection, conn, of type
seL4RPC.

=== Implement Components === Now for the implementation of the
components. Create a single source file for Hello as
apps/helloworld/components/Hello/src/hello.c: {{{\#!highlight c /\*
apps/helloworld/components/Hello/src/hello.c \*/

\#include &lt;camkes.h&gt; \#include &lt;stdio.h&gt;

void inf\_\_init(void) { }

void inf\_print(const char \*message) {

:   printf("Client says: %sn", message);

}
=

The header camkes.h is generated by the CAmkES build system and contains
prototypes for functions related to MyInterface that this component
needs to implement. Note that the actual implementations of interface
functions are prefixed with the component-local name of the interface
(inf from Hello.camkes above) and an underscore. The function
{{{inf\_\_init}}} is for this component to do any required
initialisation. In the case of this example we have no initialisation to
perform.

Create a source file for Client as
apps/helloworld/components/Client/src/client.c that calls these
functions as if they are directly available to it: {{{\#!highlight c /\*
apps/helloworld/components/Client/src/client.c \*/

\#include &lt;camkes.h&gt;

int run(void) {

:   const char \*s = "hello world"; iface\_print(s); return 0;

}
=

The entry point of a CAmkES component is run.

=== Setup Build System === The final thing is to add some build system
boiler plate to be able to build the system. Create
apps/helloworld/Kconfig for the build system menu: {{{\#!highlight
makefile \# apps/helloworld/Kconfig

config APP\_HELLOWORLD bool "Hello world CAmkES application" default n
help Hello world tutorial exercise. }}}

Create a dependency entry in apps/helloworld/Kbuild for your
application: {{{\#!highlight makefile \# apps/helloworld/Kbuild

apps-\$(CONFIG\_APP\_HELLOWORLD) += helloworld helloworld: libsel4
libmuslc libsel4platsupport
 libsel4muslccamkes libsel4sync libsel4debug libsel4bench }}}

Copy one of the Makefiles from another application or create
apps/helloworld/Makefile from scratch: {{{\#!highlight makefile \#
apps/helloworld/Makefile

TARGETS := helloworld.cdl ADL := helloworld.camkes

Client\_CFILES = components/Client/src/client.c Hello\_CFILES =
components/Hello/src/hello.c

include \${SOURCE\_DIR}/../../tools/camkes/camkes.mk }}}

Add a source line to the top-level Kconfig under the applications menu
that references this file: {{{ source "apps/helloworld/Kconfig" }}}

You can now run '''make menuconfig''' from the top-level directory and
select your application from the Applications menu. Make sure you
'''deselect the simple application''' while you're here.

=== Build and Run === You're now ready to compile and run this
application: {{{ make clean make qemu-system-arm -M kzm -nographic
-kernel
 images/capdl-loader-experimental-image-arm-imx31 }}}

If all goes well you should see: {{{ Client says: hello world }}}

Congratulations, you've just made your first CAmkES application.

=== Under the Hood === We basically just wrote a verbose and roundabout
Hello World example, so what benefit is CAmkES providing here? Note how
the function call between the two components looks just like a normal
function invocation in C, even though the two components are actually in
different address spaces. During compilation so-called glue code is
generated to connect the two components via a seL4 endpoint and
transparently pass the function invocation and return over this channel.
The communication itself is abstracted in the ADL description in
apps/helloworld/helloworld.camkes. The connection type we used was
seL4RPC, but it is possible to use another connection type here without
modifying the code of the components themselves.

== Event Application == Events are the CAmkES interface type for
modelling asynchronous communication between components. Like
procedures, events connect a single component to another single
component, but the receiver of an event (called consumer in CAmkES
parlance) has several ways of receiving the event. The following walks
through an example demonstrating these.

=== Setup Directory === Create a new application directory with two
components: {{{ mkdir -p apps/helloevent/components/Emitter mkdir -p
apps/helloevent/components/Consumer }}}

=== Setup Components' CAmkES Files === Events, unlike procedures, do not
need to be defined in a separate IDL file. You can simply refer to the
event type in your component ADL files and CAmkES will infer an event
type. Create the following description for Emitter: {{{ /\*
apps/helloevent/components/Emitter/Emitter.camkes \*/

component Emitter {

:   control; emits MyEvent e;

}
=

This description says Emitter is an active component (the control
keyword) and it emits a single event called e of type MyEvent. Create
some basic source code for the component that does nothing except emit
the event itself.

Now let's create a description of the Consumer that will handle this
event: {{{ /\* apps/helloevent/components/Consumer/Consumer.camkes \*/

component Consumer {

:   control; consumes MyEvent s;

}
=

=== Setup Composition CAmkES File === Note that this component consumes
(handles) an event of the same type. Let's instantiate and connect these
components together using another ADL file: {{{ /\*
apps/helloevent/helloevent.camkes \*/

import &lt;std\_connector.camkes&gt;; import
"components/Emitter/Emitter.camkes"; import
"components/Consumer/Consumer.camkes";

assembly {

:   

    composition {

    :   component Emitter source; component Consumer sink; connection
        seL4Notification channel(from source.e, to sink.s);

    }

}
=

In this file, seL4Notification is a seL4 specific connector for
transmitting asynchronous signals. The two instantiated components,
source and sink are connected over the connection channel.

=== Implement Components === {{{\#!highlight c /\*
apps/helloevent/components/Emitter/src/main.c \*/

\#include &lt;camkes.h&gt;

int run(void) {

:   

    while (1) {

    :   e\_emit();

    } return 0;

}
=

CAmkES provides an emit function to send the event.

As mentioned above, there are several ways for a component to receive an
event. The consumer can register a callback function to be invoked when
the event is received, they can call a blocking function that will
return when the event is received or they can call a polling function
that returns whether an event has arrived or not. Let's add some source
code that uses all three: {{{\#!highlight c /\*
apps/helloevent/components/Consumer/src/main.c \*/

\#include &lt;camkes.h&gt; \#include &lt;stdio.h&gt;

static void handler(void) {

:   static int fired = 0; printf("Callback fired!n"); if (!fired) {
    fired = 1; s\_reg\_callback(&handler, NULL); }

}

int run(void) {

:   printf("Registering callback...n"); s\_reg\_callback(&handler,
    NULL);

    printf("Polling...n"); if (s\_poll()) { printf("We found an
    event!n"); } else { printf("We didn't find an eventn"); }

    printf("Waiting...n"); s\_wait(); printf("Unblocked by an event!n");

    return 0;

}
=

Note that we re-register the callback during the first execution of the
handler. Callbacks are deregistered when invoked, so if you want the
callback to fire again when another event arrives you need to explicitly
re-register it.

=== Setup Build System === We now have everything we need to run this
system. Add the appropriate information to Kconfig,
apps/helloevent/Kbuild, apps/helloevent/Kconfig and
apps/helloevent/Makefile as for the previous example. Create
apps/helloevent/Kconfig for the build system menu: {{{\#!highlight
makefile \# apps/helloevent/Kconfig

config APP\_HELLOEVENT bool "Hello Event CAmkES application" default n
help Hello event tutorial exercise. }}}

Create a dependency entry in apps/helloevent/Kbuild for your
application: {{{\#!highlight makefile \# apps/helloevent/Kbuild

apps-\$(CONFIG\_APP\_HELLOEVENT) += helloevent helloevent: libsel4
libmuslc libsel4platsupport
 libsel4muslccamkes libsel4sync libsel4debug libsel4bench }}}

Copy one of the Makefiles from another application or create
apps/helloevent/Makefile from scratch: {{{\#!highlight makefile \#
apps/helloevent/Makefile

TARGETS := helloevent.cdl ADL := helloevent.camkes

Consumer\_CFILES = components/Consumer/src/main.c Emitter\_CFILES =
components/Emitter/src/main.c

include \${SOURCE\_DIR}/../../tools/camkes/camkes.mk }}}

Add a source line to the top-level Kconfig under the applications menu
that references this file: {{{ source "apps/helloevent/Kconfig" }}}

You can now run '''make menuconfig''' from the top-level directory and
select your application from the Applications menu. Make sure you
'''deselect the helloworld application''' while you're here.

=== Build and Run === Compile the system and run it with similar qemu
commands to the previous example: {{{ make clean make qemu-system-arm -M
kzm -nographic -kernel
 images/capdl-loader-experimental-image-arm-imx31 }}}

If all goes well you should see something like the following {{{
Registering callback... Callback fired! Polling... We didn't find an
event Waiting... Unblocked by an event! Callback fired! }}}

=== Under the Hood === Whether you find an event during polling will be
a matter of the schedule that seL4 uses to run the components. This
covers all the functionality available when using events. One final
point that may not be obvious from the example is that callbacks will
always be fired in preference to polling/waiting. That is, if a
component registers a callback and then waits on an event to arrive, the
callback will be fired when the first instance of the event arrives and
the wait will return when/if the second instance of the event arrives.

== Dataport Application == Dataports are CAmkES' abstraction of shared
memory. Dataports, like other interfaces, connect a single component to
a single other component. Both components get read/write access to the
dataport. The default dataport type is Buf, which is implemented as a
byte array in C of size PAGE\_SIZE. Alternatively you can specify a
user-defined type for the shared memory region. This example will
demonstrate both.

=== Setup Directory === Create two components that will use a pair of
dataports for communication: {{{ mkdir -p
apps/hellodataport/components/Ping mkdir -p
apps/hellodataport/components/Pong }}}

=== Setup Dataport Type === Let's define a struct that will be used as
one of the dataports: {{{\#!highlight c /\*
apps/hellodataport/include/porttype.h \*/

\#ifndef \_PORTTYPE\_H\_ \#define \_PORTTYPE\_H\_

typedef struct MyData {

:   char data\[10\];

} MyData\_t;

\#endif }}}

The build system puts some constraints on where included headers can
reside so we need to symlink this header into the place the build system
will be expecting it: {{{ mkdir -p
apps/hellodataport/components/Ping/include ln -s
../../../include/porttype.h
 apps/hellodataport/components/Ping/include/porttype.h mkdir -p
apps/hellodataport/components/Pong/include ln -s
../../../include/porttype.h
 apps/hellodataport/components/Pong/include/porttype.h }}}

=== Setup Components' CAmkES Files === Note that we need to include the
C header in the ADL. CAmkES does not actually parse this header, but it
needs to know to \#include it whenever it references the MyData\_t type.
Now let's create an ADL description of the Ping component: {{{ /\*
apps/hellodataport/components/Ping/Ping.camkes \*/

component Ping {

:   include "porttype.h"; control; dataport Buf d1; dataport MyData\_t
    d2;

}
=

Add a similar description for Pong: {{{ /\*
apps/hellodataport/components/Pong/Pong.camkes \*/

component Pong {

:   include "porttype.h"; control; dataport Buf s1; dataport MyData\_t
    s2;

}
=

=== Setup Composition CAmkES File === A real system would have a more
complete communication protocol between the two components, but for the
purposes of this example spinning until a byte changes is good enough.
We're ready to connect all these sources together with a top-level ADL
file: {{{ /\* apps/hellodataport/hellodataport.camkes \*/

import &lt;std\_connector.camkes&gt;; import
"components/Ping/Ping.camkes"; import "components/Pong/Pong.camkes";

assembly {

:   

    composition {

    :   component Ping ping; component Pong pong;

        connection seL4SharedData channel1(from ping.d1, to pong.s1);
        connection seL4SharedData channel2(from ping.d2, to pong.s2);

    }

}
=

=== Implement Components === Now we'll create some basic code for each
component to use the dataports. Note that components generally need to
use volatile variables when referring to shared memory to prevent the
compiler eliminating repeated reads and writes. {{{\#!highlight c /\*
apps/hellodataport/components/Ping/src/main.c \*/

\#include &lt;camkes.h&gt; \#include &lt;porttype.h&gt; \#include
&lt;stdio.h&gt; \#include &lt;string.h&gt;

int run(void) {

:   char \*hello = "hello";

    printf("Ping: sending %s...n", hello); strcpy((void\*)d1, hello);

    /\* Wait for Pong to reply. We can assume dataport d2 is

    :   \* zeroed on startup by seL4. \*/

    while (!d2-&gt;data\[0\]); printf("Ping: received %s.n",
    d2-&gt;data);

    return 0;

}
=

{{{\#!highlight c /\* apps/hellodataport/components/Pong/src/main.c \*/

\#include &lt;camkes.h&gt; \#include &lt;porttype.h&gt; \#include
&lt;stdio.h&gt; \#include &lt;string.h&gt;

int run(void) {

:   char \*world = "world";

    /\* Wait for Ping to message us. We can assume dataport s1 is

    :   \* zeroed on startup by seL4. \*/

    while (!\*(volatile char\*)s1); printf("Pong: received %sn",
    (volatile char\*)s1);

    printf("Pong: sending %s...n", world); strcpy((void\*)s2-&gt;data,
    world);

    return 0;

}
=

=== Setup Build System === We now have everything we need to run this
system. Add the appropriate information to Kconfig,
apps/hellodataport/Kbuild, apps/hellodataport/Kconfig and
apps/hellodataport/Makefile as for the previous example. Create
apps/hellodataport/Kconfig for the build system menu: {{{\#!highlight
makefile \# apps/hellodataport/Kconfig

config APP\_HELLODATAPORT bool "Hello Dataport CAmkES application"
default n help Hello dataport tutorial exercise. }}}

Create a dependency entry in apps/hellodataport/Kbuild for your
application: {{{\#!highlight makefile \# apps/hellodataport/Kbuild

apps-\$(CONFIG\_APP\_HELLODATAPORT) += hellodataport hellodataport:
libsel4 libmuslc libsel4platsupport
 libsel4muslccamkes libsel4sync libsel4debug libsel4bench }}}

Copy one of the Makefiles from another application or create
apps/hellodataport/Makefile from scratch: {{{\#!highlight makefile \#
apps/hellodataport/Makefile

TARGETS := hellodataport.cdl ADL := hellodataport.camkes

Ping\_CFILES = components/Ping/src/main.c Ping\_HFILES =
components/Ping/include/porttype.h Pong\_CFILES =
components/Pong/src/main.c Pong\_HFILES =
components/Pong/include/porttype.h

include \${SOURCE\_DIR}/../../tools/camkes/camkes.mk }}}

Add a source line to the top-level Kconfig under the applications menu
that references this file: {{{ source "apps/hellodataport/Kconfig" }}}

You can now run '''make menuconfig''' from the top-level directory and
select your application from the Applications menu. Make sure you
'''deselect the helloevent application''' while you're here.

=== Build and Run === Compile the system and run it with similar qemu
commands to the previous example: {{{ make clean make qemu-system-arm -M
kzm -nographic -kernel
 images/capdl-loader-experimental-image-arm-imx31 }}}

If all goes well you should see something like the following {{{ Ping:
sending hello... Pong: received hello Pong: sending world... Ping:
received world. }}}

== Better Makefile == There is a better way to write the Makefile for
your application. Take apps/hellodataport/Makefile as an example

{{{\#!highlight makefile \# apps/hellodataport/Makefile

TARGETS := \$(notdir \${SOURCE\_DIR}).cdl ADL := hellodataport.camkes

Ping\_CFILES =
 \$(patsubst \${SOURCE\_DIR}/%,%,\$(wildcard
\${SOURCE\_DIR}/components/Ping/src/*.c))
 \$(patsubst \${SOURCE\_DIR}/%,%,\$(wildcard
\${SOURCE\_DIR}/components/Ping/src/plat/\${PLAT}/*.c))
 \$(patsubst \${SOURCE\_DIR}/%,%,\$(wildcard
\${SOURCE\_DIR}/components/Ping/src/arch/\${ARCH}/\*.c))

Ping\_HFILES =
 \$(patsubst \${SOURCE\_DIR}/%,%,\$(wildcard
\${SOURCE\_DIR}/components/Ping/include/*.h))
 \$(patsubst \${SOURCE\_DIR}/%,%,\$(wildcard
\${SOURCE\_DIR}/components/Ping/include/plat/\${PLAT}/*.h))
 \$(patsubst \${SOURCE\_DIR}/%,%,\$(wildcard
\${SOURCE\_DIR}/components/Ping/include/arch/\${ARCH}/\*.h))

Pong\_CFILES =
 \$(patsubst \${SOURCE\_DIR}/%,%,\$(wildcard
\${SOURCE\_DIR}/components/Pong/src/*.c))
 \$(patsubst \${SOURCE\_DIR}/%,%,\$(wildcard
\${SOURCE\_DIR}/components/Pong/src/plat/\${PLAT}/*.c))
 \$(patsubst \${SOURCE\_DIR}/%,%,\$(wildcard
\${SOURCE\_DIR}/components/Pong/src/arch/\${ARCH}/\*.c))

Pong\_HFILES =
 \$(patsubst \${SOURCE\_DIR}/%,%,\$(wildcard
\${SOURCE\_DIR}/components/Pong/include/*.h))
 \$(patsubst \${SOURCE\_DIR}/%,%,\$(wildcard
\${SOURCE\_DIR}/components/Pong/include/plat/\${PLAT}/*.h))
 \$(patsubst \${SOURCE\_DIR}/%,%,\$(wildcard
\${SOURCE\_DIR}/components/Pong/include/arch/\${ARCH}/\*.h))

include \${SOURCE\_DIR}/../../tools/camkes/camkes.mk }}}

Variable SOURCE\_DIR will always point to application folder. In this
case, SOURCE\_DIR = camkes-project/apps/hellodataport

\$(wildcard) function will expands *.c in src/ and*.h in include/
directory \$(patsubst) function will substitute all .c .h files with
their absolute path

You can also specify platform and architecture building path if you
need.

= Tutorial Summary = You should now have a reasonably comprehensive
understanding of the basic connector functionality available in CAmkES.
The other apps in the CAmkES project repository provide some more
diverse system examples.
