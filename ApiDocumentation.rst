seL4_Send() delivers a message through the named capability. If the invoked capability is an endpoint, and no receiver is ready to receive the message immediately, the sending thread will block until the message can be delivered. No error code or response will be returned by the receiving object.

seL4_Recv() is used by a thread to receive messages through endpoints or notifications. If no sender or notification is pending, the caller will block until a message or notification can be delivered. This system call works only on Endpoint or Notification capabilities, raising a fault when attempted with other capability types.

seL4_Call() combines seL4_Send() and seL4_Recv(). The seL4 Call() operation exists not only for efficiency reasons. It differs from seL4_Send() immediately followed by seL4_Recv() in two ways: 
1. the single-use reply capability is created to establish a reply channel with minimal trust; 
2. the transition from send to recv phase is atomic, meaning it cannot be preempted, and the receiver can reply without any risk of blocking. 
When invoking capabilities to kernel services, using seL4 Call() allows the ker- nel to return an error code or other response through the reply message.

seL4_Reply() is used to respond to a seL4_Call(), using the reply capability generated by the seL4_Call() system call and stored in the replying thread’s TCB. It delivers the message to the thread that invoked the seL4_Call(), waking it in the process. There is space for only one reply capability in each thread’s TCB, so the seL4 - Reply() syscall can be used to reply to the most recent caller only. The seL4 - CNode SaveCaller() method that will be described later can be used to save the reply capability into regular capability space, where it can be used with seL4 Send().

seL4 NBSend() performs a polling send on an endpoint. It is similar to seL4 Send(), except that it is guaranteed not to block. If the message cannot be delivered immediately, i.e. there is no receiver waiting on the destination Endpoint , the message is silently dropped. Like seL4 Send(), no error code or response will be returned.







seL4 ReplyRecv() combines seL4 Reply() and seL4 Recv(). It exists mostly for efficiency reasons: the common case of replying to a request and waiting for the next can be performed in a single kernel system call instead of two. The transition from the reply to the receive phase is also atomic. seL4 NBRecv() is used by a thread to check for signals pending on a notification object or messages pending on an endpoint without blocking. This system call works only on endpoints and notification object capabilities, raising a fault (see section 6.2) when attempted with other capability types. seL4 Yield() is the only system call that does not require a capability to be used. It forfeits the remainder of the calling thread’s timeslice and causes invocation of the kernel’s scheduler. If there are no other runnable threads with the same priority as the caller, the calling thread will immediately be scheduled with a fresh timeslice.
